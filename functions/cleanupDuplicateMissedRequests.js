const functions = require("firebase-functions");
const { initializeApp } = require("firebase-admin/app");
const { getFirestore } = require("firebase-admin/firestore");

// Initialize Firebase Admin (if not already initialized)
try {
  initializeApp();
} catch (e) {
  // Already initialized
}

const db = getFirestore();

/**
 * One-time cleanup function to remove duplicate auto-generated "тасалсан" requests
 * 
 * Logic:
 * 1. Get all auto-generated "тасалсан" requests
 * 2. Group by employee + day
 * 3. For each group, keep only the most recent one, delete the rest
 * 4. If there's an approved record for that day, delete all auto-generated requests for that day
 */
exports.cleanupDuplicateMissedRequests = functions
  .region('asia-east2')
  .https.onRequest(async (req, res) => {
    // Enable CORS
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
    res.set('Access-Control-Allow-Headers', 'Content-Type');
    
    if (req.method === 'OPTIONS') {
      return res.status(200).send();
    }
    
    console.log('Starting cleanup of duplicate auto-generated missed requests...');
    
    try {
      // Get all auto-generated "тасалсан" requests
      const requestsSnapshot = await db.collection('timeAttendanceRequests')
        .where('AutoGenerated', '==', true)
        .where('Status', '==', 'тасалсан')
        .get();
      
      console.log(`Found ${requestsSnapshot.size} auto-generated тасалсан requests`);
      
      if (requestsSnapshot.empty) {
        return res.status(200).json({
          success: true,
          message: 'No auto-generated тасалсан requests found',
          deleted: 0
        });
      }
      
      // Get all approved time attendance records
      const approvedSnapshot = await db.collection('timeAttendance').get();
      
      // Build map of approved records: { "LastName_FirstName_YYYY-MM-DD": true }
      const approvedMap = {};
      approvedSnapshot.forEach(doc => {
        const data = doc.data();
        const lastName = data.LastName || data.EmployeeLastName;
        const firstName = data.FirstName || data.EmployeeFirstName;
        const day = data.Day || data.Date;
        
        if (lastName && firstName && day) {
          const key = `${lastName}_${firstName}_${day}`;
          approvedMap[key] = true;
        }
      });
      
      console.log(`Built approved map with ${Object.keys(approvedMap).length} entries`);
      
      // Group requests by employee + day
      const groupedRequests = {};
      const requestsToDelete = [];
      
      requestsSnapshot.forEach(doc => {
        const data = doc.data();
        const lastName = data.LastName;
        const firstName = data.FirstName;
        const day = data.Day;
        
        if (!lastName || !firstName || !day) {
          console.log(`Skipping request ${doc.id} - missing required fields`);
          return;
        }
        
        const key = `${lastName}_${firstName}_${day}`;
        
        // If there's an approved record for this day, mark for deletion
        if (approvedMap[key]) {
          requestsToDelete.push({
            id: doc.id,
            ref: doc.ref,
            reason: 'approved_exists',
            employee: `${lastName} ${firstName}`,
            day: day,
            createdAt: data.CreatedAt || data.CheckDate
          });
          return;
        }
        
        // Otherwise, group by employee + day
        if (!groupedRequests[key]) {
          groupedRequests[key] = [];
        }
        
        groupedRequests[key].push({
          id: doc.id,
          ref: doc.ref,
          employee: `${lastName} ${firstName}`,
          day: day,
          createdAt: data.CreatedAt || data.CheckDate,
          checkDate: data.CheckDate
        });
      });
      
      console.log(`Grouped into ${Object.keys(groupedRequests).length} unique employee-day combinations`);
      
      // For each group with multiple requests, keep the most recent, delete the rest
      let duplicateCount = 0;
      Object.keys(groupedRequests).forEach(key => {
        const requests = groupedRequests[key];
        
        if (requests.length > 1) {
          // Sort by createdAt descending (most recent first)
          requests.sort((a, b) => {
            const dateA = new Date(a.createdAt || 0);
            const dateB = new Date(b.createdAt || 0);
            return dateB - dateA;
          });
          
          // Keep the first (most recent), delete the rest
          for (let i = 1; i < requests.length; i++) {
            requestsToDelete.push({
              id: requests[i].id,
              ref: requests[i].ref,
              reason: 'duplicate',
              employee: requests[i].employee,
              day: requests[i].day,
              createdAt: requests[i].createdAt
            });
            duplicateCount++;
          }
        }
      });
      
      console.log(`Found ${requestsToDelete.length} requests to delete (${duplicateCount} duplicates + ${requestsToDelete.length - duplicateCount} with approved records)`);
      
      // Delete in batches of 500 (Firestore limit)
      let deletedCount = 0;
      const batchSize = 500;
      
      for (let i = 0; i < requestsToDelete.length; i += batchSize) {
        const batch = db.batch();
        const batchItems = requestsToDelete.slice(i, i + batchSize);
        
        batchItems.forEach(item => {
          batch.delete(item.ref);
          console.log(`Deleting: ${item.employee} on ${item.day} (${item.reason})`);
        });
        
        await batch.commit();
        deletedCount += batchItems.length;
        console.log(`Deleted batch of ${batchItems.length} requests (total: ${deletedCount})`);
      }
      
      // Summary
      const summary = {
        success: true,
        message: `Cleanup completed successfully`,
        totalAutoGenerated: requestsSnapshot.size,
        deleted: deletedCount,
        deletedWithApproved: requestsToDelete.filter(r => r.reason === 'approved_exists').length,
        deletedDuplicates: duplicateCount,
        remaining: requestsSnapshot.size - deletedCount,
        sampleDeleted: requestsToDelete.slice(0, 20).map(r => ({
          employee: r.employee,
          day: r.day,
          reason: r.reason,
          createdAt: r.createdAt
        }))
      };
      
      console.log('Cleanup summary:', summary);
      
      return res.status(200).json(summary);
      
    } catch (error) {
      console.error('Error during cleanup:', error);
      return res.status(500).json({
        success: false,
        error: error.message
      });
    }
  });
